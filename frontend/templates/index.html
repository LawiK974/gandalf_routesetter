{% extends 'base.html' %}

{% block header %}
<h1>{% block title %}{{ title }}{% endblock %}</h1>
{% endblock %}

{% block content %}
<div class="container d-flex justify-content-evenly flex-wrap">
    <div class="text-center d-inline-block">
        <h2>Boulder generator</h2>
        <label for="span-slider" class="form-label">Climber Span: <span id="span-value">170</span> cm</label>
        <input type="range" class="form-range" min="150" max="200" step="1" value="170" id="span-slider">
        <button id="generate_boulder" type="button" class="btn btn-warning">Generate boulder</button>
        <div>
            <p>Generated Boulder: <span id="generated-boulder"></span></p>
            <div style="position: relative; display: inline-block;">
                <img src="{{ image_url }}" alt="Generated Moonboard" id="moonboard-image" style="width: 100%;">
                <svg id="grid-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></svg>
            </div>
        </div>
    </div>
    <div class="text-center d-flex flex-column align-items-center">
        <div class="text-center d-inline-block">
            <h2>Most similar problems :</h2>
            <p id="similar-problem">Click the button to generate a boulder and see existing most similar problem here.</p>
        </div>
        <div class="text-center d-inline-block">
            <h2>Name generator</h2>
            <button id="generate_name" type="button" class="btn btn-warning">Generate Name</button>
            <p >Generated Name: <span id="generated-name"></span></p>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    const COLS = 11;
    const ROWS = 18;

    // Define offsets for the grid
    function getOffsets() {
        const img = document.querySelector('#moonboard-image');
        const svgWidth = img ? img.offsetWidth : 0;
        const svgHeight = img ? img.offsetHeight : 0;
        // Use percentage for left and top offset, fixed for others
        const OFFSET_LEFT = svgWidth * 0.10; // 10% of svg width
        const OFFSET_RIGHT = 20;
        const OFFSET_TOP = svgHeight * 0.06; // 7% of svg height
        const OFFSET_BOTTOM = 25;
        return { OFFSET_LEFT, OFFSET_RIGHT, OFFSET_TOP, OFFSET_BOTTOM };
    }

    function drawGridOverlay(selectedHolds) {
        const img = document.querySelector('#moonboard-image');
        const svg = document.querySelector('#grid-overlay');
        const { OFFSET_LEFT, OFFSET_RIGHT, OFFSET_TOP, OFFSET_BOTTOM } = getOffsets();
        const gridWidth = img.offsetWidth - OFFSET_LEFT - OFFSET_RIGHT;
        const gridHeight = img.offsetHeight - OFFSET_TOP - OFFSET_BOTTOM;
        const cellWidth = gridWidth / COLS;
        const cellHeight = gridHeight / ROWS;

        svg.innerHTML = ''; // Clear previous overlay

        // Draw grid lines (optional, for debugging)
        for (let i = 0; i <= COLS; i++) {
            const x = OFFSET_LEFT + i * cellWidth;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x);
            line.setAttribute('y1', OFFSET_TOP);
            line.setAttribute('x2', x);
            line.setAttribute('y2', OFFSET_TOP + gridHeight);
            line.setAttribute('stroke', 'rgba(255,255,255,0.5)'); // Increased opacity
            line.setAttribute('stroke-width', '1'); // Increased width
            svg.appendChild(line);
        }
        for (let i = 0; i <= ROWS; i++) {
            const y = OFFSET_TOP + i * cellHeight;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', OFFSET_LEFT);
            line.setAttribute('y1', y);
            line.setAttribute('x2', OFFSET_LEFT + gridWidth);
            line.setAttribute('y2', y);
            line.setAttribute('stroke', 'rgba(255,255,255,0.5)'); // Increased opacity
            line.setAttribute('stroke-width', '1'); // Increased width
            svg.appendChild(line);
        }

        // Draw circles for selected holds
        selectedHolds.forEach((hold, index) => {
            const col = hold.charCodeAt(0) - 65; // Convert A-R to 0-10
            const row = parseInt(hold.slice(1)) - 1; // Convert 1-18 to 0-17
            const cx = OFFSET_LEFT + col * cellWidth + cellWidth / 2;
            const cy = OFFSET_TOP + (ROWS - row - 1) * cellHeight + cellHeight / 2; // Reverse row calculation

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', cx);
            circle.setAttribute('cy', cy);
            circle.setAttribute('r', cellWidth * 0.4);
            circle.setAttribute('fill', 'none');
            let strokeColor;
            if (index === 0) {
                strokeColor = '#00FF00'; // Green for first
            } else if (index === selectedHolds.length - 1) {
                strokeColor = '#FF0000'; // Red for last
            } else {
                strokeColor = '#0000FF'; // Blue for others
            }
            circle.setAttribute('stroke', strokeColor);
            circle.setAttribute('stroke-width', '4');
            svg.appendChild(circle);
        });
    }

    // Update span value display
    const spanSlider = document.getElementById('span-slider');
    const spanValue = document.getElementById('span-value');
    spanSlider.addEventListener('input', function() {
        spanValue.textContent = spanSlider.value;
    });

    document.querySelector('#generate_boulder').addEventListener('click', function() {
        const span = spanSlider.value;
        fetch(`/generate?span=${span}`)
            .then(response => response.json())
            .then(data => {
                document.querySelector('#generated-boulder').textContent = data.boulder;
                // Format similar boulders as a user-friendly list
                let similarList = '';
                if (Array.isArray(data.similar) && data.similar.length > 0) {
                    similarList = '<ul class="text-start">' + data.similar.map(boulder => {
                        return `<li><b>${boulder.name}</b>, ${boulder.grade} ${boulder.userGrade? '(' + boulder.userGrade + ')' : ''} by <i>${boulder.setter}</i> ${boulder.rating}⭐️/${boulder.repeats}✅. (${boulder.holds.join(', ')})</li>`;
                    }).join('') + '</ul>';
                } else {
                    similarList = '<i>No similar boulders found.</i>';
                }
                document.querySelector('#similar-problem').innerHTML = `Existing problems, <b>${data.score}</b> similar to the IA generated problem` + similarList;

                const holds = data.boulder.split(','); // Assuming holds are comma-separated
                drawGridOverlay(holds);
            })
            .catch(error => console.error('Error:', error));
    });
    document.querySelector('#generate_name').addEventListener('click', function() {
        fetch('/generate-name')
            .then(response => response.json())
            .then(data => {
                document.querySelector('#generated-name').textContent = data.name;
            })
            .catch(error => console.error('Error:', error));
    });

    // Draw grid overlay after image loads
    window.addEventListener('load', function() {
        const img = document.querySelector('#moonboard-image');
        if (img.complete) {
            drawGridOverlay([]);
        } else {
            img.addEventListener('load', function() {
                drawGridOverlay([]);
            });
        }
    });
</script>
{% endblock %}